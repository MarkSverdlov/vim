global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'
endglobal

priority 2
# BEGIN SUPERSCRIPTS AND SUBSCRIPTS
# ------------------------------------------------ #
context "math()"
snippet "([\w]|[\}\)\]\|'])'" "Superscript" rA
`!p snip.rv = match.group(1)`^{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([\w]|[\}\)\]\|']);" "Subscript" rA
`!p snip.rv = match.group(1)`_{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([\w]|[\}\)\]\|'])sd" "Text subscript" rA
`!p snip.rv = match.group(1)`_{\mathrm{${1:${VISUAL:}}}}$0
endsnippet

context "math()"
snippet "([\w]|[\}\)\]\|'])"([\w]{1})" "Place the first \w character after the quotation mark in a subscript" rA
`!p snip.rv = match.group(1) + "^{" + match.group(2) + "}"`
endsnippet

context "math()"
snippet "([\w]|[\}\)\]\|']):([\w]{1})" "Place the first \w character after the : in a subscript" rA
`!p snip.rv = match.group(1) + "_{" + match.group(2) + "}"`
endsnippet

snippet "([\w]|[\}\)\]\|'])\*\*" "Automatic * superscript" rA
`!p snip.rv = match.group(1)`^{*}
endsnippet

snippet "([\w]|[\}\)\]\|'])TT" "Automatic transposed superscript" rA
`!p snip.rv = match.group(1)`^{\top}
endsnippet

context "math()"
snippet "([\w]|[\}\)\]\|'])CC" "Automatic complement superscript" rA
`!p snip.rv = match.group(1)`^{\complement}
endsnippet

# ----------------------------------------- #
# END SUPERSCRIPTS AND SUBSCRIPTS


# BEGIN SEMANTIC COMMANDS (vec, tilde, etc...)
# --------------------------------------------- #
snippet "(^|[^a-zA-Z])ff" "\frac{}{}" rA
`!p snip.rv = match.group(1)`\frac{${1:${VISUAL:}}}{$2}$0
endsnippet

snippet "(^|[^a-zA-Z])tf" "\tfrac{}{}" rA
`!p snip.rv = match.group(1)`\tfrac{${1:${VISUAL:}}}{$2}$0
endsnippet

context "math()"
snippet "([^a-zA-Z\\])sq" "\sqrt (square root)" rA
`!p snip.rv = match.group(1)`\sqrt{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([\W_])vv" "\vec" rA
`!p snip.rv = match.group(1)`\vec{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([\W_])uv" "\uvec" rA
`!p snip.rv = match.group(1)`\uvec{${1:${VISUAL:}}}$0
endsnippet

snippet "([\W_])mt" "\mat{} (for matrices)" rA
`!p snip.rv = match.group(1)`\mat{${1:${VISUAL:}}}$0
endsnippet

snippet "([\W_])tn" "\tensor{}" rA
`!p snip.rv = match.group(1)`\tensor{${1:${VISUAL:}}}$0
endsnippet

snippet "([\W_])wt" "\widetilde" rA
`!p snip.rv = match.group(1)`\widetilde{${1:${VISUAL:}}}$0
endsnippet

snippet "([\W_\\])hh" "\hat" rA
`!p snip.rv = match.group(1)`\hat{${1:${VISUAL:}}}$0
endsnippet

snippet "([\W_\\])bb" "\bar" rA
`!p snip.rv = match.group(1)`\bar{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([^a-zA-Z\\])aa" "\abs{}" rA
`!p snip.rv = match.group(1)`\abs{${1:${VISUAL:}}}$0
endsnippet

context "math()"
snippet "([^a-zA-Z\\])norm" "\norm{}" rA
`!p snip.rv = match.group(1)`\norm{${1:${VISUAL:}}}$0
endsnippet
# --------------------------------------------- #
# END SEMANTIC COMMANDS (vec, tilde, etc...)


# BEGIN INTEGRALS
# --------------------------------------------- #
snippet "([^\w\\])intt" "Integral with upper and lower limit" rA
`!p snip.rv = match.group(1)`\int_{$1}^{$2} $0
endsnippet

# END INTEGRALS
# --------------------------------------------- #


# BEGIN SUMS
# --------------------------------------------- #
context "math()"
snippet "([^\w\\])sM" "Sum with only lower limit" rA
`!p snip.rv = match.group(1)`\sum_{$1}$0
endsnippet

context "math()"
snippet "([^\w\\])smm" "Sum with upper and lower limit" rA
`!p snip.rv = match.group(1)`\sum_{$1}^{$2}$0
endsnippet

context "math()"
snippet "([^\w\\])lsM" "Inline math sum with only lower limit" rA
`!p snip.rv = match.group(1)`\sum \limits_{$1}$0
endsnippet

context "math()"
snippet "([^\w\\])lsmm" "Inline math sum with upper and lower limit" rA
`!p snip.rv = match.group(1)`\sum \limits_{$1}^{$2}$0
endsnippet
# --------------------------------------------- #
# END SUMS

# BEGIN LIMITS
# --------------------------------------------- #
context "math()"
snippet "([^\w\\])lm" "\lim_{}" rA
`!p snip.rv = match.group(1)`\lim_{$1}$0
endsnippet

context "math()"
snippet "([^\w\\])li" "\liminf_{}" rA
`!p snip.rv = match.group(1)`\liminf_{$1}$0
endsnippet

context "math()"
snippet "([^\w\\])ls" "\limsup_{}" rA
`!p snip.rv = match.group(1)`\limsup_{$1}$0
endsnippet

context "math()"
snippet "([^\w\\])lI" "\liminf" rA
`!p snip.rv = match.group(1)`\liminf$0
endsnippet

context "math()"
snippet "([^\w\\])lS" "\limsup" rA
`!p snip.rv = match.group(1)`\limsup$0
endsnippet

context "math()"
snippet "([^\w\\])lu" "\nnearrow" rA
`!p snip.rv = match.group(1)`\nnearrow$0
endsnippet

context "math()"
snippet "([^\w\\])ld" "\ssearrow" rA
`!p snip.rv = match.group(1)`\ssearrow$0
endsnippet
# --------------------------------------------- #
# END LIMITS


# BEGIN STATIC TEXT
# ------------------------------------- #
context "math()"
snippet and "static snippet: qquad-spaced 'and' in equation" A
\qquad \text{and} \qquad $0
endsnippet

context "math()"
snippet where "static snippet: quad-spaced 'where' in equation" A
\quad \text{where } \, $0
endsnippet

context "math()"
snippet else "\text{otherwise}" A
\text{otherwise}
endsnippet
# ------------------------------------- #
# END STATIC TEXT


# BEGIN STATIC MATH SNIPPETS
# ------------------------------------- #
snippet "([\W_])inff" "\infty" rA
`!p snip.rv = match.group(1)`\infty
endsnippet

context "math()"
snippet "([\W_])intf" "Integral from negative to positive infinity" rA
`!p snip.rv = match.group(1)`\int_{-\infty}^{\infty} 
endsnippet

context "math()"
snippet >> "\rightarrow" Ai
\rightarrow
endsnippet

context "math()"
snippet >? "\mapsto" Ai
\mapsto
endsnippet

context "math()"
snippet lq "\leq" Ai
\leq
endsnippet

context "math()"
snippet gq "\geq" Ai
\geq
endsnippet

snippet lra "\leftrightarrow" A
\leftrightarrow 
endsnippet

context "math()"
snippet "([^a-zA-Z0-9\\])df" "\diff" rA
`!p snip.rv = match.group(1)`\diff 
endsnippet

context "math()"
snippet "([^a-zA-Z0-9\\])ii" "\in" rA
`!p snip.rv = match.group(1)`\in
endsnippet

context "math()"
snippet "([^a-zA-Z0-9\\])ss" "\subset" rA
`!p snip.rv = match.group(1)`\subset
endsnippet

context "math()"
snippet qh "\qedhere" bA
\qedhere
endsnippet

context "math()"
snippet EE "\mathrm{E}" iA
\mathrm{E}
endsnippet

snippet "([lcvd])dd" "(lcvd)dots (various dots commands in one regex)" rA
\\`!p snip.rv = match.group(1)`dots
endsnippet

snippet xx "\cross" A
\times 
endsnippet

context "math()"
snippet jj "\cap" A
\cap
endsnippet

context "math()"
snippet bjj "\bigcap_{}^{}" A
\bigcap_{$1}^{$2}$0
endsnippet

context "math()"
snippet bJ "\bigcap_{}" A
\bigcap_{$1}$0
endsnippet

context "math()"
snippet uu "\cup" A
\cup
endsnippet

context "math()"
snippet buu "\bigcup_{}^{}" A
\bigcup_{$1}^{$2}$0
endsnippet

context "math()"
snippet bU "\bigcup_{}" A
\bigcup_{$1}$0
endsnippet

snippet "([^a-zA-Z0-9\\])px" "\approx" rA
`!p snip.rv = match.group(1)`\approx 
endsnippet

snippet "([^a-zA-Z0-9\\])eqq" "\equiv" rA
`!p snip.rv = match.group(1)`\equiv 
endsnippet

context "math()"
snippet "([^a-zA-Z0-9\\])NN" "\mathbb{N}" rA
`!p snip.rv = match.group(1)`\mathbb{N}
endsnippet

context "math()"
snippet "([^a-zA-Z0-9\\])RR" "\mathbb{R}" rA
`!p snip.rv = match.group(1)`\mathbb{R}
endsnippet
# ------------------------------------- #
# END STATIC MATH SNIPPETS

# BEGIN SPACING MATH SNIPPETS
# ------------------------------------- #
context "math()"
snippet ,, ",\," Ai
,\,
endsnippet
# ------------------------------------- #
# END SPACING MATH SNIPPETS
